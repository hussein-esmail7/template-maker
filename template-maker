#!/bin/bash

# === PROGRAM DESCRIPTION ===
# This program generates a template 
# file for the chosen file type. The template
# is made from a set of files that are placed 
# in the .config folder.

#########################
# Default Variables
#########################
PROMPT_TEXT="File type: "           # Prompt text during input
DATE_FORMAT=$(date '+%Y %m %d')     # Based from date format in `man date`
USERNAME=$(id -F)                   # Full name of the user
TEMPLATE_FOLDER="$HOME/.config/template-maker/copy" # Default folder path (all template files stored here)
all_filetypes=("c" "cpp" "css" "html" "java" "ms" "py" "sh" "tex") # Used for checking available file types && if template file is in 'copy' directory
quiet=0                             # Quiet mode is off unless turned on.

#########################
# Importing Configurations
#########################
CONFIG=$HOME/.config/template-maker/config      # Source the config file
if [ -f "$CONFIG" ]; then                       # If the config file exists
    source "$CONFIG"                            # Import the settings from there
else                                            # If the config file doesn't exist
    mkdir -p "$HOME/.config/template-maker"     # Make this directory if it doesn't exist
    cp "${{BASH_SOURCE[0]}/config" "$CONFIG"    # Copy the config file from the template
    if [ "$quiet" -ne 1 ]; then
        echo "Config file made at $CONFIG"
    fi
fi

# Error handling in case of empty strings in config
if [ -z "$USERNAME" ]; then
    USERNAME=$(whoami) 
fi
if [ -z "$TEMPLATE_NAME" ]; then  
    TEMPLATE_NAME="template" # Default file name
fi
if [ "${TEMPLATE_FOLDER: -1}" != "/" ] ; then # If the last character is not a "/", add it there
    TEMPLATE_FOLDER="${TEMPLATE_FOLDER}/"
fi


#########################
# Check for missing files
#########################
for file in "${all_filetypes[@]}"; do
    amount_files=$(ls -1 "${TEMPLATE_FOLDER}"*."${file}" 2>/dev/null | wc -l) # How many files in the directory
    if [[ $amount_files == 0 && "$quiet" -ne 1 ]] ; then
        echo "Missing template *.${file} file!"
        echo "Program will break if you try to make this type of file"
    fi
done

# This function finds a filename that does not exist already so it doesn't override any existing files
function make_file() { 
    # ${1} = file name without extension
    # ${2} = file extension without the ".". (Ex: a Python file will be "py", not ".py")
    # ${3} = template file name that is in the template folder
    if [[ ! -z "$shebang" || "$shebang" != "" ]]; then
        template_name="${shebang}.${2}"     # If given a filename in arguments, use that to name the file
    else
        template_name="${1}.${2}"           # If not given any arguments, use the default template name
    fi 
    counter=0
    if [ -f "$template_name" ] ; then               # If the file already exists in the directory
        while [ -f "$template_name" ] ; do          # While the next file exists, find another name  
            ((counter=counter+1))                   # Add 1 to the name counter
            template_name="${1} ($counter).${2}"    # Make a new name (wikk check on next loop)
        done                                        # Exits loop when it found an unused name
        file_name="$template_name"                  
    else                                            # If the original file name is available
        file_name="${1}.${2}"
    fi

    file_text=$(cat ${TEMPLATE_FOLDER}${3})

    # Replacing with session-specific information
    # Format: variable=${variable//ReplaceFrom/ReplaceTo}
    # // is used instead of / before ReplaceFrom to replace all occurences. / just does the first
    file_text=${file_text//"[DATE]"/$DATE_FORMAT}                 # Replace the [DATE] with the actual date with the proper formatting
    file_text=${file_text//"[CREATOR]"/$USERNAME}                 # Replace [CREATOR] with the user's actual name
    file_text=${file_text//"[FILE NAME]"/$file_name}              # Replace all mentions of the file's own name with the actual name
    file_text=${file_text//"[FILE FRONT]"/${file_name%.*}}        # File name but without the extension. Mainly used for Java

    if [ "$quiet" -ne 1 ]; then # If quiet mode is off
        echo "$file_name created."
    fi
    echo "$file_text" > "$file_name"

    exit 0
}

#########################
# Arguments handled here
#########################
user_chose_filetype=0
while getopts f:h:e: flag
do
    case "${flag}" in
        "f")  # Filename
            file_extension="${OPTARG##*.}"              # File extension only
            TEMPLATE_NAME=${OPTARG%"$file_extension"}   # File name (total text minus the extension)
            TEMPLATE_NAME="${TEMPLATE_NAME::-1}" # Remove the "." at the end (Otherwise it would make 'hello..tex' or similar).
            # echo "Base set to $file_extension"
            if [ -n "$file_extension" ]; then # If file_extension is not empty
                user_chose_filetype=1
            fi
        ;;
        "h") # Help message
            echo "=== template-maker ==="
            echo "Help message here"
            echo "-h:   Print this message."
            echo "-f:   Input the file name. If you provide an extension here, it will automatically recognize it."
            echo "-e:   Extension of the output file. If an extension is provided, the program won't have to ask you for a file type."
            echo "-q:   Quiet mode. It will only print necessary lines, like asking for file type if one wasn't given."
            # --test-install
            # -h, --help
            exit 0
        ;;
        "e") # File extension
            file_extension="${OPTARG##*.}"      # File extension only
            user_chose_filetype=1
        ;;
        "-test-install")
            # ./install
            echo "true" # Has to be here
            exit 0
        ;;
        "q") # Quiet mode
            quiet=1
        ;;
    esac
done

#########################
# Asks for the option choice
#########################
if [ "$user_chose_filetype" -eq 0 ]; then # If user hasn't chosen a file type in args
    # 'echo' statements in this block are exempt from quiet mode 
    # because required if a file type isn't given
    echo "What file do you want to create?"
    for file_type in "${all_filetypes[@]}"; do # Print all the file types
        echo ".${file_type}"
    done
    echo -n "$PROMPT_TEXT"
    read file_extension # Read the user input
    # Format the user input (get whatever's after the last "." + make all lowercase)
    file_extension=$(echo "${file_extension##*.}" | tr '[:upper:]' '[:lower:]')
fi

#########################
# Figure out what the user typed + Call the make_file 
# function that (you guessed it) makes the file
#########################
case "$file_extension" in 
    "exit") exit 0                                              ;;  # Exit the program
    "q")    exit 0                                              ;;  # Exit the program
    "c")    make_file "$TEMPLATE_NAME" "c" "template.c"         ;;  # C programming file
    "cpp")  make_file "$TEMPLATE_NAME" "cpp" "template.cpp"     ;;  # C++ programming file
    "css")  make_file "style" "css" "style.css"                 ;;  # CSS programming file
    "html") make_file "index" "html" "index.html"               ;;  # HTML File
    "java") make_file "$TEMPLATE_NAME" "java" "template.java"   ;;  # Java programming file
    "ms")   make_file "$TEMPLATE_NAME" "ms" "template.ms"       ;;  # Groff markup file
    "py")   make_file "$TEMPLATE_NAME" "py" "template.py"       ;;  # Python programming file
    "sh")   make_file "$TEMPLATE_NAME" "sh" "template.sh"       ;;  # Bash shell script
    "tex")  make_file "$TEMPLATE_NAME" "tex" "template.tex"     ;;  # LaTeX Typeset Document
    *)      echo "Invalid option: '$REPLY'"; exit 1             ;;  # If user types wacky stuff
esac

exit 0
